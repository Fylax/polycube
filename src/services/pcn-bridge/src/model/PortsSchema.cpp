/**
* bridge API
* bridge API generated from bridge.yang
*
* OpenAPI spec version: 1.0.0
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
*/

/* Do not edit this file manually */

#include "PortsSchema.h"

namespace io {
namespace swagger {
namespace server {
namespace model {

PortsSchema::PortsSchema() {
  m_Status = "";
  m_StatusIsSet = false;
  m_Name = "";
  m_NameIsSet = false;
  m_Address = "";
  m_AddressIsSet = false;
  m_AccessIsSet = false;
  m_StpIsSet = false;
  m_Mode = "";
  m_ModeIsSet = false;
  m_TrunkIsSet = false;
  m_Peer = "";
  m_PeerIsSet = false;
  m_Uuid = "";
  m_UuidIsSet = false;
}

PortsSchema::~PortsSchema() {}

void PortsSchema::validate() {
  // TODO: implement validation
}

nlohmann::json PortsSchema::toJson() const {
  nlohmann::json val = nlohmann::json::object();

  if (m_StatusIsSet) {
    val["status"] = m_Status;
  }

  if (m_NameIsSet) {
    val["name"] = m_Name;
  }

  if (m_AddressIsSet) {
    val["address"] = m_Address;
  }

  if (m_AccessIsSet) {
    val["access"] = ModelBase::toJson(m_Access);
  }

  {
    nlohmann::json jsonArray;
    for (auto &item : m_Stp) {
      jsonArray.push_back(ModelBase::toJson(item));
    }

    if (jsonArray.size() > 0) {
      val["stp"] = jsonArray;
    }
  }
  if (m_ModeIsSet) {
    val["mode"] = m_Mode;
  }

  if (m_TrunkIsSet) {
    val["trunk"] = ModelBase::toJson(m_Trunk);
  }
  if (m_PeerIsSet) {
    val["peer"] = m_Peer;
  }

  if (m_UuidIsSet) {
    val["uuid"] = m_Uuid;
  }

  return val;
}

void PortsSchema::fromJson(nlohmann::json &val) {
  if (val.find("status") != val.end()) {
    setStatus(val.at("status"));
  }

  if (val.find("name") != val.end()) {
    setName(val.at("name"));
  }

  if (val.find("address") != val.end()) {
    setAddress(val.at("address"));
  }

  if (val.find("access") != val.end()) {
    if (!val["access"].is_null()) {
      PortsAccessSchema newItem;
      newItem.fromJson(val["access"]);
      setAccess(newItem);
    }
  }

  m_Stp.clear();
  for (auto &item : val["stp"]) {
    PortsStpSchema newItem;
    newItem.fromJson(item);
    m_Stp.push_back(newItem);
  }

  if (val.find("mode") != val.end()) {
    setMode(val.at("mode"));
  }

  if (val.find("trunk") != val.end()) {
    if (!val["trunk"].is_null()) {
      PortsTrunkSchema newItem;
      newItem.fromJson(val["trunk"]);
      setTrunk(newItem);
    }
  }

  if (val.find("peer") != val.end()) {
    setPeer(val.at("peer"));
  }

  if (val.find("uuid") != val.end()) {
    setUuid(val.at("uuid"));
  }
}

nlohmann::json PortsSchema::getKeys() {
  nlohmann::json val = nlohmann::json::object();

  val["name"]["name"] = "name";
  val["name"]["type"] = "key";
  val["name"]["simpletype"] = "string";
  val["name"]["description"] = R"POLYCUBE(Port Name)POLYCUBE";
  val["name"]["example"] = R"POLYCUBE()POLYCUBE";

  return val;
}

nlohmann::json PortsSchema::getElements() {
  nlohmann::json val = nlohmann::json::object();

  val["status"]["name"] = "status";
  val["status"]["type"] = "leaf";  // Suppose that type is leaf
  val["status"]["simpletype"] = "string";
  val["status"]["description"] =
      R"POLYCUBE(Status of the port (UP or DOWN))POLYCUBE";
  val["status"]["example"] = R"POLYCUBE()POLYCUBE";
  val["status"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "Status of the port (UP or DOWN)",
  "enum" : [ "UP", "DOWN" ]
})POLYCUBE");
  val["address"]["name"] = "address";
  val["address"]["type"] = "leaf";  // Suppose that type is leaf
  val["address"]["simpletype"] = "string";
  val["address"]["description"] = R"POLYCUBE(MAC address of the port)POLYCUBE";
  val["address"]["example"] = R"POLYCUBE()POLYCUBE";
  val["address"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "MAC address of the port"
})POLYCUBE");
  val["access"]["name"] = "access";
  val["access"]["type"] = "leaf";  // Suppose that type is leaf
  val["access"]["description"] = R"POLYCUBE()POLYCUBE";
  val["access"]["example"] = R"POLYCUBE()POLYCUBE";
  val["access"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "$ref" : "#/definitions/PortsAccessSchema"
})POLYCUBE");
  val["stp"]["name"] = "stp";
  val["stp"]["type"] = "leaf";  // Suppose that type is leaf
  val["stp"]["type"] = "list";
  val["stp"]["description"] =
      R"POLYCUBE(Per-vlan Spanning Tree Protocol Port Configuration)POLYCUBE";
  val["stp"]["example"] = R"POLYCUBE()POLYCUBE";
  val["stp"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "array",
  "description" : "Per-vlan Spanning Tree Protocol Port Configuration",
  "items" : {
    "$ref" : "#/definitions/PortsStpSchema"
  },
  "x-key" : [ "vlan" ]
})POLYCUBE");
  val["mode"]["name"] = "mode";
  val["mode"]["type"] = "leaf";  // Suppose that type is leaf
  val["mode"]["simpletype"] = "string";
  val["mode"]["description"] =
      R"POLYCUBE(Type of bridge interface: access/trunk)POLYCUBE";
  val["mode"]["example"] = R"POLYCUBE()POLYCUBE";
  val["mode"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "Type of bridge interface: access/trunk",
  "enum" : [ "access", "trunk" ],
  "default" : "access"
})POLYCUBE");
  val["trunk"]["name"] = "trunk";
  val["trunk"]["type"] = "leaf";  // Suppose that type is leaf
  val["trunk"]["description"] = R"POLYCUBE()POLYCUBE";
  val["trunk"]["example"] = R"POLYCUBE()POLYCUBE";
  val["trunk"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "$ref" : "#/definitions/PortsTrunkSchema"
})POLYCUBE");
  val["peer"]["name"] = "peer";
  val["peer"]["type"] = "leaf";  // Suppose that type is leaf
  val["peer"]["simpletype"] = "string";
  val["peer"]["description"] =
      R"POLYCUBE(Peer name, such as a network interfaces (e.g., 'veth0') or another cube (e.g., 'br1:port2'))POLYCUBE";
  val["peer"]["example"] = R"POLYCUBE()POLYCUBE";
  val["peer"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "Peer name, such as a network interfaces (e.g., 'veth0') or another cube (e.g., 'br1:port2')"
})POLYCUBE");
  val["uuid"]["name"] = "uuid";
  val["uuid"]["type"] = "leaf";  // Suppose that type is leaf
  val["uuid"]["simpletype"] = "string";
  val["uuid"]["description"] = R"POLYCUBE(UUID of the port)POLYCUBE";
  val["uuid"]["example"] = R"POLYCUBE()POLYCUBE";
  val["uuid"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "UUID of the port",
  "readOnly" : true
})POLYCUBE");

  return val;
}

nlohmann::json PortsSchema::getWritableLeafs() {
  nlohmann::json val = nlohmann::json::object();

  val["status"]["name"] = "status";
  val["status"]["simpletype"] = "string";
  val["status"]["description"] =
      R"POLYCUBE(Status of the port (UP or DOWN))POLYCUBE";
  val["status"]["example"] = R"POLYCUBE()POLYCUBE";
  val["status"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "Status of the port (UP or DOWN)",
  "enum" : [ "UP", "DOWN" ]
})POLYCUBE");
  val["address"]["name"] = "address";
  val["address"]["simpletype"] = "string";
  val["address"]["description"] = R"POLYCUBE(MAC address of the port)POLYCUBE";
  val["address"]["example"] = R"POLYCUBE()POLYCUBE";
  val["address"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "MAC address of the port"
})POLYCUBE");
  val["mode"]["name"] = "mode";
  val["mode"]["simpletype"] = "string";
  val["mode"]["description"] =
      R"POLYCUBE(Type of bridge interface: access/trunk)POLYCUBE";
  val["mode"]["example"] = R"POLYCUBE()POLYCUBE";
  val["mode"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "Type of bridge interface: access/trunk",
  "enum" : [ "access", "trunk" ],
  "default" : "access"
})POLYCUBE");
  val["peer"]["name"] = "peer";
  val["peer"]["simpletype"] = "string";
  val["peer"]["description"] =
      R"POLYCUBE(Peer name, such as a network interfaces (e.g., 'veth0') or another cube (e.g., 'br1:port2'))POLYCUBE";
  val["peer"]["example"] = R"POLYCUBE()POLYCUBE";
  val["peer"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "Peer name, such as a network interfaces (e.g., 'veth0') or another cube (e.g., 'br1:port2')"
})POLYCUBE");

  return val;
}

nlohmann::json PortsSchema::getComplexElements() {
  nlohmann::json val = nlohmann::json::object();

  val["access"]["name"] = "access";
  val["access"]["type"] = "complex";
  val["access"]["description"] = R"POLYCUBE()POLYCUBE";
  val["access"]["example"] = R"POLYCUBE()POLYCUBE";
  val["stp"]["name"] = "stp";
  val["stp"]["type"] = "list";
  val["stp"]["description"] =
      R"POLYCUBE(Per-vlan Spanning Tree Protocol Port Configuration)POLYCUBE";
  val["stp"]["example"] = R"POLYCUBE()POLYCUBE";
  val["trunk"]["name"] = "trunk";
  val["trunk"]["type"] = "complex";
  val["trunk"]["description"] = R"POLYCUBE()POLYCUBE";
  val["trunk"]["example"] = R"POLYCUBE()POLYCUBE";

  return val;
}

std::string PortsSchema::getStatus() const {
  return m_Status;
}

void PortsSchema::setStatus(std::string value) {
  m_Status = value;
  m_StatusIsSet = true;
}

bool PortsSchema::statusIsSet() const {
  return m_StatusIsSet;
}

void PortsSchema::unsetStatus() {
  m_StatusIsSet = false;
}
std::string PortsSchema::getName() const {
  return m_Name;
}

void PortsSchema::setName(std::string value) {
  m_Name = value;
  m_NameIsSet = true;
}

bool PortsSchema::nameIsSet() const {
  return m_NameIsSet;
}

void PortsSchema::unsetName() {
  m_NameIsSet = false;
}
std::string PortsSchema::getAddress() const {
  return m_Address;
}

void PortsSchema::setAddress(std::string value) {
  m_Address = value;
  m_AddressIsSet = true;
}

bool PortsSchema::addressIsSet() const {
  return m_AddressIsSet;
}

void PortsSchema::unsetAddress() {
  m_AddressIsSet = false;
}
PortsAccessSchema PortsSchema::getAccess() const {
  return m_Access;
}

void PortsSchema::setAccess(PortsAccessSchema value) {
  m_Access = value;
  m_AccessIsSet = true;
}

bool PortsSchema::accessIsSet() const {
  return m_AccessIsSet;
}

void PortsSchema::unsetAccess() {
  m_AccessIsSet = false;
}
std::vector<PortsStpSchema> &PortsSchema::getStp() {
  return m_Stp;
}

bool PortsSchema::stpIsSet() const {
  return m_StpIsSet;
}

void PortsSchema::unsetStp() {
  m_StpIsSet = false;
}
std::string PortsSchema::getMode() const {
  return m_Mode;
}

void PortsSchema::setMode(std::string value) {
  m_Mode = value;
  m_ModeIsSet = true;
}

bool PortsSchema::modeIsSet() const {
  return m_ModeIsSet;
}

void PortsSchema::unsetMode() {
  m_ModeIsSet = false;
}
PortsTrunkSchema PortsSchema::getTrunk() const {
  return m_Trunk;
}

void PortsSchema::setTrunk(PortsTrunkSchema value) {
  m_Trunk = value;
  m_TrunkIsSet = true;
}

bool PortsSchema::trunkIsSet() const {
  return m_TrunkIsSet;
}

void PortsSchema::unsetTrunk() {
  m_TrunkIsSet = false;
}
std::string PortsSchema::getPeer() const {
  return m_Peer;
}

void PortsSchema::setPeer(std::string value) {
  m_Peer = value;
  m_PeerIsSet = true;
}

bool PortsSchema::peerIsSet() const {
  return m_PeerIsSet;
}

void PortsSchema::unsetPeer() {
  m_PeerIsSet = false;
}
std::string PortsSchema::getUuid() const {
  return m_Uuid;
}

void PortsSchema::setUuid(std::string value) {
  m_Uuid = value;
  m_UuidIsSet = true;
}

bool PortsSchema::uuidIsSet() const {
  return m_UuidIsSet;
}

void PortsSchema::unsetUuid() {
  m_UuidIsSet = false;
}
}
}
}
}
