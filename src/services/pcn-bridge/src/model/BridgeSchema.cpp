/**
* bridge API
* bridge API generated from bridge.yang
*
* OpenAPI spec version: 1.0.0
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
*/

/* Do not edit this file manually */

#include "BridgeSchema.h"

namespace io {
namespace swagger {
namespace server {
namespace model {

BridgeSchema::BridgeSchema() {
  m_FilteringdatabaseIsSet = false;
  m_Name = "";
  m_NameIsSet = false;
  m_Agingtime = 0;
  m_AgingtimeIsSet = false;
  m_Stpenabled = false;
  m_StpenabledIsSet = false;
  m_StpIsSet = false;
  m_Type = "";
  m_TypeIsSet = false;
  m_PortsIsSet = false;
  m_Uuid = "";
  m_UuidIsSet = false;
}

BridgeSchema::~BridgeSchema() {}

void BridgeSchema::validate() {
  // TODO: implement validation
}

nlohmann::json BridgeSchema::toJson() const {
  nlohmann::json val = nlohmann::json::object();

  {
    nlohmann::json jsonArray;
    for (auto &item : m_Filteringdatabase) {
      jsonArray.push_back(ModelBase::toJson(item));
    }

    if (jsonArray.size() > 0) {
      val["filteringdatabase"] = jsonArray;
    }
  }
  if (m_NameIsSet) {
    val["name"] = m_Name;
  }

  if (m_AgingtimeIsSet) {
    val["agingtime"] = m_Agingtime;
  }

  if (m_StpenabledIsSet) {
    val["stpenabled"] = m_Stpenabled;
  }

  {
    nlohmann::json jsonArray;
    for (auto &item : m_Stp) {
      jsonArray.push_back(ModelBase::toJson(item));
    }

    if (jsonArray.size() > 0) {
      val["stp"] = jsonArray;
    }
  }

  if (m_TypeIsSet) {
    val["type"] = m_Type;
  }

  {
    nlohmann::json jsonArray;
    for (auto &item : m_Ports) {
      jsonArray.push_back(ModelBase::toJson(item));
    }

    if (jsonArray.size() > 0) {
      val["ports"] = jsonArray;
    }
  }
  if (m_UuidIsSet) {
    val["uuid"] = m_Uuid;
  }

  return val;
}

void BridgeSchema::fromJson(nlohmann::json &val) {
  m_Filteringdatabase.clear();
  for (auto &item : val["filteringdatabase"]) {
    FilteringdatabaseSchema newItem;
    newItem.fromJson(item);
    m_Filteringdatabase.push_back(newItem);
  }

  if (val.find("name") != val.end()) {
    setName(val.at("name"));
  }

  if (val.find("agingtime") != val.end()) {
    setAgingtime(val.at("agingtime"));
  }

  if (val.find("stpenabled") != val.end()) {
    setStpenabled(val.at("stpenabled"));
  }

  m_Stp.clear();
  for (auto &item : val["stp"]) {
    StpSchema newItem;
    newItem.fromJson(item);
    m_Stp.push_back(newItem);
  }

  if (val.find("type") != val.end()) {
    setType(val.at("type"));
  }

  m_Ports.clear();
  for (auto &item : val["ports"]) {
    PortsSchema newItem;
    newItem.fromJson(item);
    m_Ports.push_back(newItem);
  }

  if (val.find("uuid") != val.end()) {
    setUuid(val.at("uuid"));
  }
}

nlohmann::json BridgeSchema::getKeys() {
  nlohmann::json val = nlohmann::json::object();

  val["name"]["name"] = "name";
  val["name"]["type"] = "key";
  val["name"]["simpletype"] = "string";
  val["name"]["description"] = R"POLYCUBE(Name of the bridge service)POLYCUBE";
  val["name"]["example"] = R"POLYCUBE()POLYCUBE";

  return val;
}

nlohmann::json BridgeSchema::getElements() {
  nlohmann::json val = nlohmann::json::object();

  val["filteringdatabase"]["name"] = "filteringdatabase";
  val["filteringdatabase"]["type"] = "leaf";  // Suppose that type is leaf
  val["filteringdatabase"]["type"] = "list";
  val["filteringdatabase"]["description"] =
      R"POLYCUBE(Entry associated with the filtering database)POLYCUBE";
  val["filteringdatabase"]["example"] = R"POLYCUBE()POLYCUBE";
  val["filteringdatabase"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "array",
  "description" : "Entry associated with the filtering database",
  "items" : {
    "$ref" : "#/definitions/FilteringdatabaseSchema"
  },
  "x-key" : [ "vlan", "address" ]
})POLYCUBE");
  val["agingtime"]["name"] = "agingtime";
  val["agingtime"]["type"] = "leaf";  // Suppose that type is leaf
  val["agingtime"]["simpletype"] = "integer";
  val["agingtime"]["description"] =
      R"POLYCUBE(Aging time of the filtering database)POLYCUBE";
  val["agingtime"]["example"] = R"POLYCUBE()POLYCUBE";
  val["agingtime"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "integer",
  "format" : "uint32",
  "description" : "Aging time of the filtering database"
})POLYCUBE");
  val["stpenabled"]["name"] = "stpenabled";
  val["stpenabled"]["type"] = "leaf";  // Suppose that type is leaf
  val["stpenabled"]["simpletype"] = "boolean";
  val["stpenabled"]["description"] =
      R"POLYCUBE(Enable/Disable the STP protocol of the bridge)POLYCUBE";
  val["stpenabled"]["example"] = R"POLYCUBE()POLYCUBE";
  val["stpenabled"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "boolean",
  "description" : "Enable/Disable the STP protocol of the bridge",
  "default" : false
})POLYCUBE");
  val["stp"]["name"] = "stp";
  val["stp"]["type"] = "leaf";  // Suppose that type is leaf
  val["stp"]["type"] = "list";
  val["stp"]["description"] =
      R"POLYCUBE(Per-vlan Spanning Tree Protocol Configuration)POLYCUBE";
  val["stp"]["example"] = R"POLYCUBE()POLYCUBE";
  val["stp"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "array",
  "description" : "Per-vlan Spanning Tree Protocol Configuration",
  "items" : {
    "$ref" : "#/definitions/StpSchema"
  },
  "x-key" : [ "vlan" ]
})POLYCUBE");
  val["type"]["name"] = "type";
  val["type"]["type"] = "leaf";  // Suppose that type is leaf
  val["type"]["simpletype"] = "string";
  val["type"]["description"] =
      R"POLYCUBE(Type of the Cube (TC, XDP_SKB, XDP_DRV))POLYCUBE";
  val["type"]["example"] = R"POLYCUBE()POLYCUBE";
  val["type"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "Type of the Cube (TC, XDP_SKB, XDP_DRV)",
  "enum" : [ "TC", "XDP_SKB", "XDP_DRV" ]
})POLYCUBE");
  val["ports"]["name"] = "ports";
  val["ports"]["type"] = "leaf";  // Suppose that type is leaf
  val["ports"]["type"] = "list";
  val["ports"]["description"] = R"POLYCUBE(Entry of the ports table)POLYCUBE";
  val["ports"]["example"] = R"POLYCUBE()POLYCUBE";
  val["ports"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "array",
  "description" : "Entry of the ports table",
  "items" : {
    "$ref" : "#/definitions/PortsSchema"
  },
  "x-key" : [ "name" ]
})POLYCUBE");
  val["uuid"]["name"] = "uuid";
  val["uuid"]["type"] = "leaf";  // Suppose that type is leaf
  val["uuid"]["simpletype"] = "string";
  val["uuid"]["description"] = R"POLYCUBE(UUID of the Cube)POLYCUBE";
  val["uuid"]["example"] = R"POLYCUBE()POLYCUBE";
  val["uuid"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "UUID of the Cube",
  "readOnly" : true
})POLYCUBE");

  return val;
}

nlohmann::json BridgeSchema::getWritableLeafs() {
  nlohmann::json val = nlohmann::json::object();

  val["agingtime"]["name"] = "agingtime";
  val["agingtime"]["simpletype"] = "integer";
  val["agingtime"]["description"] =
      R"POLYCUBE(Aging time of the filtering database)POLYCUBE";
  val["agingtime"]["example"] = R"POLYCUBE()POLYCUBE";
  val["agingtime"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "integer",
  "format" : "uint32",
  "description" : "Aging time of the filtering database"
})POLYCUBE");
  val["stpenabled"]["name"] = "stpenabled";
  val["stpenabled"]["simpletype"] = "boolean";
  val["stpenabled"]["description"] =
      R"POLYCUBE(Enable/Disable the STP protocol of the bridge)POLYCUBE";
  val["stpenabled"]["example"] = R"POLYCUBE()POLYCUBE";
  val["stpenabled"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "boolean",
  "description" : "Enable/Disable the STP protocol of the bridge",
  "default" : false
})POLYCUBE");
  val["type"]["name"] = "type";
  val["type"]["simpletype"] = "string";
  val["type"]["description"] =
      R"POLYCUBE(Type of the Cube (TC, XDP_SKB, XDP_DRV))POLYCUBE";
  val["type"]["example"] = R"POLYCUBE()POLYCUBE";
  val["type"]["jsonSchema"] = nlohmann::json::parse(R"POLYCUBE({
  "type" : "string",
  "description" : "Type of the Cube (TC, XDP_SKB, XDP_DRV)",
  "enum" : [ "TC", "XDP_SKB", "XDP_DRV" ]
})POLYCUBE");

  return val;
}

nlohmann::json BridgeSchema::getComplexElements() {
  nlohmann::json val = nlohmann::json::object();

  val["filteringdatabase"]["name"] = "filteringdatabase";
  val["filteringdatabase"]["type"] = "list";
  val["filteringdatabase"]["description"] =
      R"POLYCUBE(Entry associated with the filtering database)POLYCUBE";
  val["filteringdatabase"]["example"] = R"POLYCUBE()POLYCUBE";
  val["stp"]["name"] = "stp";
  val["stp"]["type"] = "list";
  val["stp"]["description"] =
      R"POLYCUBE(Per-vlan Spanning Tree Protocol Configuration)POLYCUBE";
  val["stp"]["example"] = R"POLYCUBE()POLYCUBE";
  val["ports"]["name"] = "ports";
  val["ports"]["type"] = "list";
  val["ports"]["description"] = R"POLYCUBE(Entry of the ports table)POLYCUBE";
  val["ports"]["example"] = R"POLYCUBE()POLYCUBE";

  return val;
}

std::vector<FilteringdatabaseSchema> &BridgeSchema::getFilteringdatabase() {
  return m_Filteringdatabase;
}

bool BridgeSchema::filteringdatabaseIsSet() const {
  return m_FilteringdatabaseIsSet;
}

void BridgeSchema::unsetFilteringdatabase() {
  m_FilteringdatabaseIsSet = false;
}
std::string BridgeSchema::getName() const {
  return m_Name;
}

void BridgeSchema::setName(std::string value) {
  m_Name = value;
  m_NameIsSet = true;
}

bool BridgeSchema::nameIsSet() const {
  return m_NameIsSet;
}

void BridgeSchema::unsetName() {
  m_NameIsSet = false;
}
int32_t BridgeSchema::getAgingtime() const {
  return m_Agingtime;
}

void BridgeSchema::setAgingtime(int32_t value) {
  m_Agingtime = value;
  m_AgingtimeIsSet = true;
}

bool BridgeSchema::agingtimeIsSet() const {
  return m_AgingtimeIsSet;
}

void BridgeSchema::unsetAgingtime() {
  m_AgingtimeIsSet = false;
}
bool BridgeSchema::getStpenabled() const {
  return m_Stpenabled;
}

void BridgeSchema::setStpenabled(bool value) {
  m_Stpenabled = value;
  m_StpenabledIsSet = true;
}

bool BridgeSchema::stpenabledIsSet() const {
  return m_StpenabledIsSet;
}

void BridgeSchema::unsetStpenabled() {
  m_StpenabledIsSet = false;
}
std::vector<StpSchema> &BridgeSchema::getStp() {
  return m_Stp;
}

bool BridgeSchema::stpIsSet() const {
  return m_StpIsSet;
}

void BridgeSchema::unsetStp() {
  m_StpIsSet = false;
}
std::string BridgeSchema::getType() const {
  return m_Type;
}

void BridgeSchema::setType(std::string value) {
  m_Type = value;
  m_TypeIsSet = true;
}

bool BridgeSchema::typeIsSet() const {
  return m_TypeIsSet;
}

void BridgeSchema::unsetType() {
  m_TypeIsSet = false;
}
std::vector<PortsSchema> &BridgeSchema::getPorts() {
  return m_Ports;
}

bool BridgeSchema::portsIsSet() const {
  return m_PortsIsSet;
}

void BridgeSchema::unsetPorts() {
  m_PortsIsSet = false;
}
std::string BridgeSchema::getUuid() const {
  return m_Uuid;
}

void BridgeSchema::setUuid(std::string value) {
  m_Uuid = value;
  m_UuidIsSet = true;
}

bool BridgeSchema::uuidIsSet() const {
  return m_UuidIsSet;
}

void BridgeSchema::unsetUuid() {
  m_UuidIsSet = false;
}
}
}
}
}
